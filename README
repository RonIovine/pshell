NAME:

PSHELL - A Lightweight, Process-Specific, Embedded Command Line Shell

INTRODUCTION:

This package contains all the necessary code, documentation and examples for
building C/C++/Python applications that incorporate a Process Specific Embedded 
Command Line Shell (PSHELL).  The PSHELL library provides a simple, lightweight,
framework and API to embed functions within a C/C++/Python application that can 
be invoked either via a separate client program or directly from the within
application itself.

There is also a control API provided by where any external program can invoke another
program's registered pshell functions (only supported for UDP or UNIX pshell servers).
This will provide direct programmatic control of a remote process' pshell functions 
without having to fork the calling process to call the 'pshell' command line client 
program via the 'system' call.

The control API can function as an IPC mechanism for control between processes.  If 
all process control is implemented as a collection of pshell commands, you can get 
a programmitic IPC mechanism along with manual CLI/Shell access via the same code 
base.  There is no need to write separate CLI/Shell processing code and control/message
event handling code.

The control API supports both unicast and multicast messaging paradigms.  It also 
supports messaging to broadcast pshell servers (i.e. UDP server running at a subnet 
broadcast address, e.g. x.y.z.255).

The Python and 'C' versions are consistent with each other at the API level (i.e. similar 
functional API, usage, process interaction etc) and fully interoperable with each other at 
the protocol level and can be mixed and matched in any combination, i.e. the 'C' libraries 
and UDP/UNIX client can control and interface transparently to the Python applications and 
vice-versa.  A telnet client can interface to both 'C' and Python based pshell servers.

The prototype for the 'C' callback functions are similar to the 'main' in 'C' as follows:

void myFunc(int argc, char *argv[]);

The prototype for the Python callback functions are as follows:

def myFunc(argv):

Command line pshell functions can also display information back to the interactive clients 
via a mechanism similar to the familiar 'printf' as follows:

void pshell_printf(const char *format, ...);

The Python versions have a similar mechanism:

def printf(string):

These functions can be invoked in several ways depending on how the internal PSHELL server is 
configured.  The following shows the various PSHELL server types along with their associated 
invokation method:

TCP Server   : Uses standard 'telnet' interactive client to invoke functions
UDP Server   : Uses included 'pshell' interactive client or control API to invoke functions
UNIX Server  : Uses included 'pshell' interactive client or control API to invoke functions
LOCAL Server : No client program needed, functions invoked directly from within application 
               itself via local command line interactive prompting

The functions are dispatched via its registered command name (keyword), along with 0 or more 
command line arguments, similar to command line shell processing.

This framework also provides the ability to run in non-server, non-interactive mode.  In this
mode, the registered commands can be dispatched via the host's shell command line directly as 
single shot commands via the main registering program.  In this mode, there is no interactive 
user prompting, and control is returned to the calling host's command line shell when the command 
is complete.  This mode also provides the ability to setup softlink shortcuts to each internal 
command and to invoke those commands from the host's command line shell directly via the shortcut 
name rather than the parent program name, in a manner similar Busybox functionality.

This package also provides an optional integrated interactive dynamic trace filtering mechanism 
that can be incorporated into any software that uses an existing trace logging system that uses 
the `__FILE__`, `__LINE__`, `__FUNCTION__`, and `level` paradigm.  If this functionality is not 
desired, it can be easily compiled out via the build-time config files.

Along with the optional trace filtering mechanism, there is also an optional integrated trace logging
subsystem and API to show the integration of an existing logging system into the dynamic trace filter
API.  The output of this logging system can be controlled via the trace filter pshell CLI mechanism.
This example logging system can also be compiled out via the build-time config files if an existing
logging system is used.

In addition to the infrastructure components, ten demo programs are also provided, two (C and
Python) to show the usage of the pshell server API, two (C and Python) to show the usage of pshell 
control API, two (C and Python) to show the aggergation of multiple pshell servers into a single 
pshell server via the control API, one to show the usage of the trace filter/trace log API, one to 
show the usage of a stand-alone (no filtering) trace log application, and one to show the usage of 
the multi-call binary API.

Finally, a stub module/library is provided that will honor the complete API of the normal pshell
library but with all the underlying functionality stubbed out.  This will allow all the pshell 
functionality to easily be completly removed from an application without requiring any code 
changes or recompilation, only a re-link (for static linking) or restart (when using a shared 
library/module acessed via a softlink) of the target program is necessary.

GETTING STARTED:

This package consists of the following components, all provided binaries (libs
and executables) were built for the x86_64 target.  The script pshell.exp
requires the 'expect' package to be installed.

  - install.sh               -- Install shell script for this package
  - uninstall.sh             -- Uninstall shell script for this package
  - defconfig                -- Default configuration file for build process
  - Makefile                 -- File for building all libraries and executables
  - libpshell-server-full.a  -- Full version of libpshell-server library (static)
  - libpshell-server-full.so -- Full version of libpshell-server library (shared)
  - libpshell-server-stub.a  -- Stub version of libpshell-server library (static)
  - libpshell-server-stub.so -- Stub version of libpshell-server library (shared)
  - libpshell-control.so     -- External pshell program control libpshell-control library (shared)
  - libpshell-control.a      -- External pshell program control libpshell-control library (static)
  - PshellServer.py          -- Python version of PshellServer functionality (UDP, UNIX and LOCAL only)
  - PshellControl.py         -- External pshell program control Python module
  - PshellReadline.py        -- Provides a readline like funtionality Python module
  - pshell                   -- Stand-alone PSHELL UDP/UNIX client remote access program
  - pshell.py                -- Python version of stand-alone PSHELL UDP/UNIX client remote access program
  - pshell.exp               -- Expect script telnet wrapper to provide interface similar to the
                                UDP/UNIX pshell client when using the TCP server with a telnet client
  - archivePshell            -- Shell script to create a pshell-vX.Y.tar.gz archive
  - setPshellLib             -- Shell script to set the libpshell-server.so softlink to desired library
  - showPshelllLib           -- Shell script to show the current libpshell-server.so softlink setting
  - pshellServerDemo         -- Demo application using the pshell server library features
  - pshellServerDemo.py      -- Demo application using the pshell server Python module features
  - pshellNoServerDemo       -- Demo application using non-server option of the pshell library
  - pshellControlDemo        -- Demo application using the pshell control library features
  - pshellControlDemo.py     -- Demo application using the pshell control Python module features
  - pshellAggregatorlDemo    -- Demo application using the pshell control library to aggregate multiple servers
  - pshellAggregatorlDemo.py -- Demo application using the pshell control Python module to aggregate multiple servers
  - pshellReadlineDemo.py    -- Demo application using the PshellReadline Python module to solicit user input
  - traceFilterDemo          -- Demo application using the optional trace filter features
  - traceLogDemo             -- Demo application using the stand-alone TraceLog module

INSTALLATION:

This package can either be installed on the target host for system wide usage, or
in a local directory for limited access.  There is an installation script provided
in the top level of the unzipped package (i.e. same directory as this README file)
that will do the different installs.  This package has binaries built for an x86_64
target that have been tested on CentOs (RedHat derivitave) and Mint (Ubuntu derivitave)
Linux distributions.  It has also been successfully built and run on a ARM based
Raspberry Pi system running Raspbian Linux as well as a Windows/Cygwin based system.  
If using this package for a a different target, see the following section on building 
from source.

To see the usage of the script 'cd' to the top level pshell directory and type:

$ ./install.sh -h

Usage: install.sh [-local [<shellEnvFile>]]

  This install script will either install this package on a system
  wide basis or will setup a local install environment.  A system
  install must be done as 'root' and will copy all libraries, binaries,
  include files, conf files, and manpages to their customary system
  locations.  A local install will not copy/move any files.  It will
  only create a pshell env file (.pshellrc) that can be sourced in the
  current shell or can be added to your shell env file (i.e. .bashrc)
  that will allow use of the package features from a local directory.

  The location of the local install environment will be the directory
  where this script resides.

  where:
    local        - install locally, omit for system install
    shellEnvFile - optional name of shell environment file to modify
                   (e.g. full path to your .bashrc)

Then run the script with the desired inputs and follow any instructions (local install only).

ENVIRONMENT:

If the install script is run to setup local access, the following environment variables
are written to the .pshellrc shell environment file, source that env file to setup
your environment.

export PSHELL_INSTALL=<myLocalInstallDir>
export PSHELL_BATCH_DIR=$PSHELL_INSTALL/batch
export PSHELL_STARTUP_DIR=$PSHELL_INSTALL/startup
export PSHELL_CONFIG_DIR=$PSHELL_INSTALL/config
export PATH=$PSHELL_INSTALL/bin:$PSHELL_INSTALL/utils:$PSHELL_INSTALL/python:$PSHELL_INSTALL/python/demo:$PATH
export MANPATH=$PSHELL_INSTALL/man:$MANPATH
export LD_LIBRARY_PATH=$PSHELL_INSTALL/lib:$LD_LIBRARY_PATH
export PYTHONPATH=$PSHELL_INSTALL/python:$PSHELL_INSTALL/python/demo:$PYTHONPATH

Note that if a system wide install is done, none of the 'demo' programs are installed
in any system wide 'bin' directories.  They can only be executed directly from the 'bin'
directory of the unzipped package.  If a local install is done and its environment
sourced, the environment variables setup will allow the execution of the 'demo' programs
from any location.

DOCUMENTATION:

The following manpages are available from the above configured MANPATH or
from the standard manpage locations on a system installation:

pshell(1)        - Describes the framework as well as the client program
PshellServer(3)  - Describes the API and usage of the PshellServer utility
PshellControl(3) - Describes the API and usage of the PshellControl utility
TraceFilter(3)   - Describes the API and usage of the TraceFilter utility
TraceLog(3)      - Describes the API and usage of the TraceLog utility

The following HTML 'pydoc' generated documentation is available in the
$PSHELL_INSTALL/python/doc directory:

pshell.html
PshellServer.html
PshellControl.html
PshellReadline.html

A complete code example of application programs that use all the
main features of the PSHELL library can be found in the files:

$PSHELL_INSTALL/demo/pshellServerDemo.cc             --  Server demo for user defined commands
$PSHELL_INSTALL/demo/pshellControlDemo.cc            --  Sample pshell control external client
$PSHELL_INSTALL/demo/pshellAggregatorDemo.cc         --  Sample pshell control to aggregate multiple servers
$PSHELL_INSTALL/demo/traceFilterDemo.cc              --  Server demo for dynamic trace filtering
$PSHELL_INSTALL/demo/traceLogDemo.cc                 --  Demo using the stand-alone TraceLog module
$PSHELL_INSTALL/demo/pshellNoServerDemo.cc           --  Demo using the multi-call binary option
$PSHELL_INSTALL/python/demo/pshellServerDemo.py      --  Server demo for user defined commands (Python)
$PSHELL_INSTALL/python/demo/pshellControlDemo.py     --  Sample pshell control external client (Python)
$PSHELL_INSTALL/python/demo/pshellAggregatorDemo.py  --  Sample pshell control to aggregate multiple servers (Python)
$PSHELL_INSTALL/python/demo/pshellReadlineDemo.py    --  Sample program to show usage of PshellReadline (Python)

EXECUTION:

There are 10 demo programs, two that demonstrate a program that incorporates a
pshell server (pshellServerDemo and pshellServerDemo.py), one that demonstrates 
a program that incorporates the trace filter functionality (traceFilterDemo), two 
that demonstrate the control of a program that is running a pshell server from 
another program (pshellControlDemo and pshellControlDemo.py), two that demonstrate 
the aggregation of multiple pshell servers into a single server via the control
API (pshellAggregatorDemo, pshellAggregatorDemo.py), one that demonstrates the 
usage of readline-like command line user input (pshellReadlineDemo.py), one that 
demonstrates the stand-alone usage of the TraceLog API (traceLogDemo), and one 
that demonstrates the use of the multi-call binary API (pshellNoServerDemo).

All demo programs have a usage that can be displayed by typing <programName> -h.
The two demo programs pshellServerDemo and traceFilterDemo can be controlled via
an interactive client program (either pshell or telnet) that shows the full command
line functionality.  The demo program pshellControlDemo can control the other two demo
programs through a simple command line UI, but it is really meant to demonstrate the
programmitic control of an external program that is running a PshellServer via the
PshellControl API and library.  The pshellControlDemo programs can control either the
pshellServerDemo or traceControlDemo program.  The pshellAggregatorDemos can control both 
the pshellServerDemo or traceControlDemo within a single invocation.  The functionality 
of the pshellNoServerDemo is only accessed directly from the host's command line shell, 
either directly from the pshellNoServerDemo itself, or via the setup softlinks for each 
command (need to run 'pshellNoServerDemo --setup' to setup softlinks).

After the install.sh script has been excuted (and the local env sourced if doing
a local install), the client and associated demo programs can be run.  Run
"pshellServerDemo" and connect to it with the "pshell" client program for a
UDP/UNIX server, or telnet (or the pshell.exp telnet expect script wrapper) for
a TCP server.  Note, to use the "pshell.exp" expect script you need to have the
"expect" package installed on your host in /usr/bin.

(NOTE: To see the features of the dynamically configurable optional TraceFilter
mechanism, run the program "traceFilterDemo".  It can be controlled via the same
command line 'pshell' or 'telnet' client as "pshellServerDemo", so all following
usage descriptions also apply.

The usage of the "pshellServerDemo" program is as follows:

$ pshellServerDemo -h

Usage: pshellServerDemo -udp | -unix | -tcp | -local

  where:
    -udp   - Multi-session UDP server
    -unix  - Multi-session UNIX server
    -tcp   - Single session TCP server
    -local - Local command dispatching server

Execute "pshellServerDemo -udp" or "pshellServerDemo -unix" at the command line,
either in the foreground or background.  You can now interact with the 
"pshellServerDemo" program via the "pshell" client program.  Note, you can also
run the "pshellServerDemo" program with the "-tcp" option and connect with the
expect script "pshell.exp" which wraps a telnet session to make the look and
feel be similar to the UDP/UNIX "pshell" client program.  The usage of the
"pshell.exp" script is the same as the "pshell" UDP/UNIX client program shown
below with the exception of the "-t<timeout>" option and the "batch"
interactive command not being supported.  Also note that the TCP server is a
single session server with a 10 minute idle session timeout, whereas the
UDP/UNIX server is a multi-session server with no idle session timeout.
Conversly, you can also connect to the TCP server by using telnet directly
(i.e. "telnet localhost 6001") instead of the "pshell.exp" expect script telnet
wrapper.

The usage of the "pshell" and "pshell.exp" (see NOTE) command line client
programs are as follows:

Usage: pshell -h | ? | -s | [-t<timeout>] {<hostName> | <ipAddress> | unix} 
               {<serverName> | <portNum>} [-h | ? | {<command> [<rate> [clear]]} | 
               {-f <fileName> [<rate> [clear]]}]

  where:

    -h,?       - show pshell usage or command set of specified PSHELL server
    -s         - show named servers in $PSHELL_CONFIG_DIR/pshell-client.conf file
    -f         - run commands from a batch file
    -t         - change the default server response timeout
    hostName   - hostname of desired PSHELL server (UDP only)
    ipAddress  - IP address of desired PSHELL server (UDP only)
    unix       - Specifies server is a UNIX domain server
    serverName - name of desired PSHELL server (UDP or UNIX)
    portNum    - port number of desired PSHELL server (UDP only)
    timeout    - value in seconds to use for server response timeout
    command    - optional command to execute
    fileName   - optional batch file to execute
    rate       - optional rate to repeat command or batch file (in seconds)
    clear      - clear screen between commands or batch file passes

    NOTE: If no <command> is given, pshell will be started
          up in interactive mode, commands issued in command
          line mode that require arguments must be enclosed
          in double quotes, commands issued in interactive
          mode that require arguments do not require double
          quotes.

          To get help on a command in command line mode, type
          "<command> ?" or "<command> -h".  To get help in
          interactive mode type 'help' or '?' at the prompt to
          see all available commands, to get help on a single
          command, type '<command> {? | -h}'.  Use TAB completion
          to fill out partial commands and up-arrow to recall
          the last entered command.

NOTE: The "-t<timeout>" option, the "unix" specifier are only
      supported on the UDP/UNIX client/server.

Invoke the pshell client program per the above usage.  The pshellServerDemo
program uses the identifier "localhost" for the hostname, this name
name should be used for the hostname given to the pshell client.

EXAMPLES:

The following is an example of how to enter into interactive mode
with the pshellServerDemo program:

$ pshell localhost pshellServerDemo

Once this command is invoked, an interactive command line prompt is
given as follows:

pshellServerDemo[127.0.0.1]:PSHELL>

The following is an example of specifying a different server response
timeout value.  If a value is given, the default response timeout of
5 seconds will be replaced by this value (UDP/UNIX client only).

$ pshell -t20 localhost pshellServerDemo

Commands can then be entered interactivley.  The following example shows
how to display the command list in interactive mode (note that "?" also work):

pshellServerDemo[127.0.0.1]:PSHELL> help

The following shows the same command entered in command line mode:

$ pshell localhost pshellServerDemo -h

The following shows an example of executing a command with arguments:

pshellServerDemo[127.0.0.1]:PSHELL> hello 1 2 3

The following shows the same command entered in command line mode:

$ pshell localhost pshellServerDemo "hello 1 2 3"

The following shows how to execute command from a batch file in
interactive mode (UDP/UNIX client only):

pshellServerDemo[127.0.0.1]:PSHELL> batch pshellServerDemo.batch

The following shows the same command entered in command line mode:

$ pshell localhost pshellServerDemo -f pshellServerDemo.batch

The following example shows how to display the usage of a given command
in ineractive mode (note that "-h" also works)

pshellServerDemo[127.0.0.1]:PSHELL> hello ?

The following shows the same command entered in command line mode,
note that "-h" will also accomplish the same thing:

$ pshell localhost pshellServerDemo "hello ?"

The following example shows executing a command at a periodic rate
(every 1 second), this feature is available only in command line mode
(note, if no arguments are given for the command, the double quotes
are not necessary):

$ pshell localhost pshellServerDemo "hello 1 2 3" 1

The following example shows the same command as above but clearing the
screen before each command

$ pshell localhost pshellServerDemo "hello 1 2 3" 1 clear

The following example shows executing a batch file at a periodic rate
(every 1 second), this feature is available only in command line mode.

$ pshell localhost pshellServerDemo -f pshellServerDemo.batch 1

The following example shows the same command as above but clearing the
screen before each invocation of the batch file

$ pshell localhost pshellServerDemo -f pshellServerDemo.batch 1 clear

The final example shows how to list all the named PSHELL servers in the
$PSHELL_CONFIG_DIR/pshell-client.conf file, this is also only available
in command line mode:

$ pshell -s

BUILDING:

This package includes x86_64 binaries and libraries that were built and tested on
CentOS Linux 6.6 (RedHat base) and Linux Mint 17 (Debian/Ubuntu base).  They
should be able to run on any modern Linux x86_64 distribution as is.  However, if
a build is necessary for different target hardware, a Makefile along with config
files are provided.  The 'defconfig' file has the default settings for various
build-time compilation settings.  This file should not be modified, but rather
copied to '.config', which should then be modified as necessary.  The settings
in the '.config' file are then used for the build process.  If no modifications
are desired in the build settings, there is no need to copy 'defconfig' to
'.config' as during the build process, if no '.config' is found, the copy will
be done automatically by the makefile processing.

This package has been successfully re-built and run on a Raspberry Pi/ARM based
system running Raspbian Linux as well as a Windows/Cygwin based system.

NOTE: While an overriding design goal was to write all the code in standard ANSI
      C and use standard C linkages, and a standard functional 'C' API, there are
      a couple of small places where some C++ semantics snuck in, namely with 
      function prototypes that take default parameters and one struct that has 
      a constructor.  Because of this, all the source modules have a '.cc' C++
      style extension instead of the customary '.c' C style extension in order 
      to be able to use the standard 'gcc' compiler as well the 'g++' compiler.

The following is the usage of the Makefile, see the included 'defconfig' file for
all the build-time options and their descriptions:

Usage: make {all | pshell | lib | demo | install | clean} [verbose=y] [local=y [shellEnvFile=<file>]]

  where:
    all          - build all components of the pshell package
    pshell       - build the pshell UDP stand-alone client program only
    lib          - build the pshell link libraries only (shared, static and stub)
    demo         - build the pshell stand-alone demo programs only
    install      - build and install all pshell components
    clean        - clean all binaries (libs & executables)
    verbose      - print verbose messages for build process
    local        - specify local install (install target only)
    shellEnvFile - shell env file (i.e. .bashrc) to modify for local install

  NOTE: The install target option will either install this package on a
        system wide basis or will setup a local install environment.  A system
        install must be done as 'root' and will copy all libraries, binaries,
        include files, conf files, and manpages to their customary system
        locations.  A local install will not copy/move any files.  It will
        only create a pshell env file (.pshellrc) that can be sourced in the
        current shell or can be added to your shell env file (i.e. .bashrc)
        that will allow use of the package features from a local directory.

        The location of the local install environment will be the directory
        where this script resides.

SECURITY:

This package provides for remote interaction and control of a process
running the PshellServer application via an IP based client/server paradigm.
The pshell protocol used to communicate between the client and server is an
unencrypted plain text protocol.  As such, if security is an issue, it
should be treated as any other unsecure protocol, such as telnet.  The
local target's PshellServer IP address and port should only be exposed within
a local network or secure VPN, but should not be exposed for general use
over untrusted networks, such as the public Internet.  For maximum security
between the client and server, the server can be run either as a UNIX domain
server or at the target host's local loopback address (i.e. 127.0.0.1) and the
PSHELL client application (pshell) can be installed to run on the same local 
host as the target application.  Of course, a secure mechanism (like ssh) would 
then need to be used to provide a secure user access method to that host.

PORTING:

This package was written to run on Unix/Linux type platforms and their
derivitaves.  This does not preclude this package from being ported to
any other operating system.  All that is needed is basic BSD socket and
posix thread support.  The API is a standard 'C' functional API, an attempt
was made to stick with standard ANSI 'C' as much as possible, however,
a very few small concessions to C++ we made, see the notes in the BUILDING
section about the deatils.

Ron Iovine

Copyright 2009 Ron Iovine

github.com/RonIovine/pshell
