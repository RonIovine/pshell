#!/usr/bin/python

#################################################################################
# 
# Copyright (c) 2009, Ron Iovine, All rights reserved.  
#  
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of Ron Iovine nor the names of its contributors 
#       may be used to endorse or promote products derived from this software 
#       without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY Ron Iovine ''AS IS'' AND ANY EXPRESS OR 
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
# IN NO EVENT SHALL Ron Iovine BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
# POSSIBILITY OF SUCH DAMAGE. 
#
#################################################################################

################################################################################
#
# logProfiler:
#
# This program will provide the ability to perform code performance analysis
# based on a logfile that was generated by programs that instrument their code
# with trace log statements that use a file, function, line, and timestamp
#
# This profiler understands logfile entries of the following formats:
#
# app | level | 14:40:32.377256 | file(function):line | user-message
# app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
# 2014-08-17 23:11:00.114 level [app:file:line] user-message
# 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
# 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
#
# Modify the functions 'parseLine' and 'findApp' to add additional log 
# entry formats
#
################################################################################

# import all our necessary modules
import sys
import re
import os
import datetime
import operator
import PshellReadline

##############################
#
# global data
#
##############################

# modify the following items for different trace log line formats
gTimestampFormat = "%H:%M:%S.%f"

# modify to use the desired keep alive indication,
# valid values are 'lines', 'wheel', 'dots', and 'none'
gKeepAliveType = "lines"

# display formatting constants
gBanner = "LOGFILE PROFILER"
gBannerLength = len(gBanner)

gAreaLabel1 = "START CODE AREA"
gMinArea1Width = len(gAreaLabel1)

gAreaLabel2 = "END CODE AREA"
gMinArea2Width = len(gAreaLabel2)

gCountLabel = "COUNT"
gLabelSuffix = ""
gCountLabelLength = len(gCountLabel)+len(gLabelSuffix)+1

gTotTimeLabel = "TOT TIME"
gMaxTimeLabel = "MAX TIME"
gMinTimeLabel = "MIN TIME"
gAvgTimeLabel = "AVG TIME"
gMedTimeLabel = "MED TIME"
gStdDevLabel = "STD DEV"

gTimeDeltaLength = 14
gTimeDeltaCount = 6

gUnderline = "="

gSpaceLength = 2

gNormalDisplayColumns = 11
gNormalDisplayPadLength = gSpaceLength*(gNormalDisplayColumns-1)

gClearStatusUpdate = "\r"

gTimestampEndings = (']', '|', ' ')
gTimestampPositions = {0, 1, 3, 4}
gTimestampFormat = "%H:%M:%S.%f"
gTimestampRegexp0 = '\d{2}:\d{2}:\d{2}.\d{3}'
gTimestampRegexp1 = '\d{2}:\d{2}:\d{2}.\d{4}'
gTimestampRegexp2 = '\d{2}:\d{2}:\d{2}.\d{5}'
gTimestampRegexp3 = '\d{2}:\d{2}:\d{2}.\d{6}'
gTimestampRegexp4 = '\d{4}-\d{2}-\d{2}Td{2}:\d{2}:\d{2}.\d{5}'
gGreen = "\33[0;32m"
gRed = "\33[0;31m"
gAmber = "\33[0;33m"
gHighlight = gAmber
gNormal = "\33[0m"

# various keep alive global variables
gValidKeepAliveTypes = ('wheel', 'dots', 'lines', 'none')
gWheel = ('|', '/', '-', '\\')
gWheelIndex = 0

# command line option switches and default values
gValidOptions = ('-tot', '-min', '-max', '-avg', '-med', '-std', '-count')
gValidSort = ('tot', 'min', 'max', 'avg', 'med', 'std', 'count')
gValidDiffs = ('percent', 'time')
gDiffRequested = False
gTimeSuffix = ""
gTimeWidthAdjust = 0
gCountSuffix = ""
gCountWidthAdjust = 0
gTotalProfiledTime = datetime.timedelta(0)
gDisplayAll = "all"
gNoFilter = "none"
gNoSort = "none"
gNoOption = "none"
gMaxAreaWidth1 = 0
gMaxAreaWidth2 = 0

# global profile lists
gProfiles = []
gProfilesDiff = []
gProfilesDelta = []

#####################################################
#
# display the program usage
#
#####################################################
def showUsage():
  print("")
  print("Usage: logProfiler <logfile1>[:<appId>] [<logfile2>[:<appId>]...<logfileN>[:<appId>]]")
  print("")
  print("  where:")
  print("    <appId> : Specify an app filter (process name or pid)")
  print("")
  print("  This program will provide the ability to perform code performance analysis")
  print("  based on a logfile that was generated by programs that instrument their code")
  print("  with trace log statements that use a file, function, line, and timestamp")
  print("")
  print("  This program will currently work with log entries of the following formats:")
  print("")
  print("  app | level | 14:40:32.377256 | file(function):line | user-message")
  print("  app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message ")
  print("  2014-08-17 23:11:00.114 level [app:file:line] user-message")
  print("  2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message")
  print("  2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message")
  print("")
  print("  Use the 'app' filter when working with logfiles that contain logs from")
  print("  multiple apps, e.g. syslog etc.")
  print("")
  print("  Modify the functions 'parseLine' and 'findApp' to add additional log entry formats")
  print("")
  sys.exit()

#####################################################
#
# print a keep alive indicator
#
#####################################################
def printKeepAlive(numLines, totalLines, type):
  global gWheel
  global gWheelIndex
  global gClearStatusUpdate
  if (type == "wheel"):
    if (numLines == 0):
      sys.stdout.write("%s%s%s" % ("\b"*17, " "*17, "\b"*17))
      sys.stdout.flush()
    if ((numLines % 1000) == 0):
      sys.stdout.write("%s\b" % gWheel[gWheelIndex])
      sys.stdout.flush()
      gWheelIndex += 1
      gWheelIndex = gWheelIndex % len(gWheel)
  elif (type == "dots"):
    if (numLines == 0):
      sys.stdout.write("%s%s%s" % ("\b"*20, " "*20, "\b"*20))
      sys.stdout.flush()
    if ((numLines % 5000) == 0):
      sys.stdout.write(".")
      sys.stdout.flush()
  elif (type == "lines"):
    gClearStatusUpdate = "\n\n"
    sys.stdout.write("%s of %s%s" % (str(numLines+1).ljust(len(str(totalLines))), totalLines, "\b"*(len(str(totalLines))*2+4)))
    sys.stdout.flush()
  else:
    if (numLines == 0):
      sys.stdout.write("%s%s%s" % ("\b"*17, " "*17, "\b"*17))
      sys.stdout.flush()

#####################################################
#
# convert a timedelta time to seconds
#
#####################################################
def timeDeltaToSec(timeDelta):
  return float(timeDeltaToUsec(timeDelta) / 1000000.0)

#####################################################
#
# convert a timedelta time to microseconds
#
#####################################################
def timeDeltaToUsec(timeDelta):
  return abs(timeDelta.microseconds + (timeDelta.seconds + timeDelta.days * 86400) * 1000000)

#####################################################
#
# calculated the median times for all the profiles
#
#####################################################
def calculateMedian(profiles):
  for profile in profiles:
    profile["delta"].sort()
    if (len(profile["delta"]) == 1):
      profile["med"] = profile["delta"][0]
    elif (len(profile["delta"])%2 == 0):
      timeDelta1 = profile["delta"][len(profile["delta"])/2-1]
      timeDelta2 = profile["delta"][len(profile["delta"])/2]
      profile["med"] = (timeDelta1+timeDelta2)/2
    else:
      profile["med"] = profile["delta"][len(profile["delta"])/2]

#########################################################
#
# calculated the standard deviation for all the profiles
#
#########################################################
def calculateStdDeviation(profiles):
  for profile in profiles:
    sumDiffSquared = 0.0
    for timeDelta in profile["delta"]:
      sumDiffSquared = (timeDeltaToUsec(timeDelta)-timeDeltaToUsec(profile["avg"]))**2 + sumDiffSquared
    profile["stdDev"] = datetime.timedelta(microseconds=((sumDiffSquared)/len(profile["delta"]))**(1.0/2.0))

#####################################################
#
# find a profile based on filename/function
#
#####################################################
def findProfile(profiles, filename1, function1, line1, filename2, function2, line2):
  for profile in profiles:
    if ((profile["file1"] == filename1) and (profile["function1"] == function1) and (profile["line1"] == line1) and
        (profile["file2"] == filename2) and (profile["function2"] == function2) and (profile["line2"] == line2)):
      return (profile)
  return (None)

######################################################################
#
# return the file, function, line, and timestamp from the input line
#
######################################################################
def parseLine(line):
  
  # change this line parsing function for different log line formats,
  # we need to extract the file, function, line, and timestamp, an
  # example of the currently parsed log line formats are:
  #
  # app | level | 14:40:32.377256 | file(function):line | user-message
  # app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
  # 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
  # 2014-08-17 23:11:00.114 level [app:file:line] user-message
  # 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
  #

  # parse format: 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
  expectedNumTokens = 8
  timestampTokenPos = 2
  functionTokenPos = 6
  locationTokenPos = 7
  tokens = line.split()
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    location = tokens[locationTokenPos].strip().split("@")
    if ((timestamp != "") and (len(location) == 2)):
      filename = location[0]
      line = location[1][:-1]
      function = tokens[functionTokenPos].strip().split(":")[0]
      return (filename, "("+function+")", ":"+line, timestamp)
  
  # parse format: 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
  expectedNumTokens = 6
  timestampTokenPos = 0
  functionTokenPos = 4
  locationTokenPos = 5
  tokens = line.split()
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    location = tokens[locationTokenPos].strip().split("@")
    if ((timestamp != "") and (len(location) == 2)):
      filename = location[0]
      line = location[1][:-1]
      function = tokens[functionTokenPos].strip().split(":")[0]
      return (filename, "("+function+")", ":"+line, timestamp)

  # parse format: app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
  expectedNumTokens = 6
  timestampTokenPos = 1
  filenameTokenPos = 2
  lineTokenPos = 3
  functionTokenPos = 4
  tokens = line.split("|")
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    if (timestamp != ""):
      filename = os.path.basename(tokens[filenameTokenPos].strip())
      line = tokens[lineTokenPos].strip()
      function = tokens[functionTokenPos].strip()
      return (filename, "("+function+")", ":"+line, timestamp)
  
  # parse format: app | level | 14:40:32.377256 | file(function):line | user-message
  expectedNumTokens = 5
  timestampTokenPos = 2
  filenameTokenPos = 3
  lineTokenPos = filenameTokenPos
  functionTokenPos = filenameTokenPos
  tokens = line.split("|")
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    if (timestamp != ""):
      filename = tokens[filenameTokenPos].strip().split("(")[0]
      line = tokens[lineTokenPos].strip().split(":")[-1]
      function = tokens[functionTokenPos].strip().split("(")[-1]
      function = function.split(")")[0]
      return (filename, "("+function+")", ":"+line, timestamp)
  
  # parse format: 2014-08-17 23:11:00.114 level [app:file:line] user-message
  expectedNumTokens = 4
  timestampTokenPos = 1
  locationTokenPos = 3
  tokens = line.split()
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    location = tokens[locationTokenPos].strip().split(":")
    if ((timestamp != "") and (len(location) == 3)):
      filename = location[1]
      line = location[2][:-1]
      # this format does not have a function, so we just return ""
      return (filename, "", ":"+line, timestamp)
  
  # dropped through, return nothing
  return (None, None, None, None)
  
######################################################################
#
# return true if line matches app filter
#
######################################################################
def findApp(line, appFilter):
  global gNoFilter
  
  # change this line parsing function for different log line formats,
  # we need to extract the file, function, line, and timestamp, an
  # example of the currently parsed log line formats are:
  #
  # app | level | 14:40:32.377256 | file(function):line | user-message
  # app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
  # 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
  # 2014-08-17 23:11:00.114 level [app:file:line] user-message
  # 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
  #

  if (appFilter != gNoFilter):

    # parse format: 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
    expectedNumTokens = 8
    appTokenPos = 5
    tokens = line.split()
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip().split(":")[0]
      if (app == appFilter):
        return (True)
  
    # parse format: 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
    expectedNumTokens = 6
    appTokenPos = 3
    tokens = line.split()
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip().split(":")[0]
      if (app == appFilter):
        return (True)

    # parse format: app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
    expectedNumTokens = 6
    appTokenPos = 0
    tokens = line.split("|")
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip()
      if (app == appFilter):
        return (True)
  
    # parse format: app | level | 14:40:32.377256 | file(function):line | user-message
    expectedNumTokens = 5
    appTokenPos = 0
    tokens = line.split("|")
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip()
      if (app == appFilter):
        return (True)
  
    # parse format: 2014-08-17 23:11:00.114 level [app:file:line] user-message
    expectedNumTokens = 4
    locationTokenPos = 3
    tokens = line.split()
    if (len(tokens) >= expectedNumTokens):
      location = tokens[locationTokenPos].strip().split(":")
      app = location[0][1:]
      if (app == appFilter):
        return (True)
  
    # dropped through, return nothing
    return (False)
  
  else:
    return (True)

######################################################
#
# update an existing area profile or create a new one
#
######################################################
def updateProfile(profiles, prevLine, currLine):
  
  global gTotalProfiledTime
  global gMaxAreaWidth1
  global gMaxAreaWidth2
  
  (filename1, function1, line1, timestamp1) = parseLine(prevLine)
  (filename2, function2, line2, timestamp2) = parseLine(currLine)
  
  if ((filename1 != None) and (filename2 != None)):
  
    # both lines are good, now either update an existing area profile, or create a new one
    currTime = datetime.datetime.strptime(timestamp2, gTimestampFormat)
    prevTime = datetime.datetime.strptime(timestamp1, gTimestampFormat)
    timeDelta = currTime - prevTime
    # filter out any negative timeDelta, this could happen if the system time
    # has changed during the creation of a logfile or at the midnight rollover
    if (timeDelta >= datetime.timedelta(0)):
      profile = findProfile(profiles["profile"], filename1, function1, line1, filename2, function2, line2)
      if (profile == None):
        # create new profile
        areaWidth1 = len(filename1)+len(function1)+len(line1)
        areaWidth2 = len(filename2)+len(function2)+len(line2)
        profiles["profile"].append({"file1":filename1,
                                    "function1":function1,
                                    "line1":line1,
                                    "areaWidth1":areaWidth1,
                                    "file2":filename2,
                                    "function2":function2,
                                    "line2":line2,
                                    "areaWidth2":areaWidth2,
                                    "count":0,
                                    "tot":datetime.timedelta(0),
                                    "min":datetime.timedelta.max,
                                    "max":datetime.timedelta.min,
                                    "avg":datetime.timedelta(0),
                                    "med":datetime.timedelta(0),
                                    "stdDev":datetime.timedelta(0),
                                    "delta":[]})
        profile = profiles["profile"][-1]
        if (areaWidth1 > gMaxAreaWidth1):
          gMaxAreaWidth1 = areaWidth1
        if (areaWidth2 > gMaxAreaWidth2):
          gMaxAreaWidth2 = areaWidth2
      profile["count"] += 1
      profile["tot"] += timeDelta
      gTotalProfiledTime += timeDelta
      profile["avg"] = profile["tot"]/profile["count"]
      profile["delta"].append(timeDelta)
      if (timeDelta > profile["max"]):
        profile["max"] = timeDelta
      if (timeDelta < profile["min"]):
        profile["min"] = timeDelta

#####################################################
#
# creates the specified profile
#
#####################################################
def createProfile(logfile):
  global gKeepAliveType
  global gTimestampFormat
  global gTotalProfiledTime
  global gProfiles
  global gNoFilter
  gTotalProfiledTime = datetime.timedelta(0)
  appFilter = logfile.split(":")
  if (len(appFilter) == 2):
    logfile = appFilter[0]
    appFilter = appFilter[1]
    logfile1 = logfile + "(" + appFilter + ")"
  else:
    logfile1 = logfile
    appFilter = gNoFilter
  if (os.path.isfile(logfile)):
    # create a new profile  for this logfile
    profile = {"logfile":logfile1, 
               "appFilter":appFilter,
               "contents":open(logfile, 'r').readlines(),
               "totTime":datetime.timedelta(0),
               "profiledTime":datetime.timedelta(0),
               "profile":[]}
    print("")
    sys.stdout.write("Creating run time profile from logfile: %s, please wait...processing line: " % logfile)
    numLines = 0
    currLine = None
    prevLine = None
    currTimestamp = ""
    for line in profile["contents"]:
      printKeepAlive(numLines, len(profile["contents"]), gKeepAliveType)
      if (findApp(line, appFilter) == True):
        if (currTimestamp != ""):
          prevLine = currLine
        currLine = line
        currTimestamp = findTimestamp(currLine)
        if ((numLines > 0) and (currTimestamp != "") and (prevLine != None)):
          updateProfile(profile, prevLine, currLine)
      numLines += 1
    profile["profiledTime"] = gTotalProfiledTime;
    calculateMedian(profile["profile"])
    calculateStdDeviation(profile["profile"])
    # add new profile to our profile list
    gProfiles.append(profile)
    return (True)
  else:
    print("")
    print("ERROR: logfile: '%s' not found..." % logfile)
    return (False)

#####################################################
#
# shows time display
#
#####################################################
def getTimeDisplay(time, labelLength):
  global gTimeSuffix
  global gTimeWidthAdjust
  global gDiffRequested
  global gDiffType
  # make the display of a 0 time display the microseconds part,
  # a 0 time delta does not display the microseconds by default
  if (time == datetime.timedelta(0)):
    time = "0:00:00.000000"
  if (gDiffRequested):
    if (gDiffType == "percent"):
      width = 10
    else:
      width = 9
    if (time > 0):
      return (("+"+str(time)).rjust(width)+gTimeSuffix).rjust(labelLength-gTimeWidthAdjust)
    else:
      return (str(time).rjust(width)+gTimeSuffix).rjust(labelLength-gTimeWidthAdjust)
  else:
    return (str(time)+gTimeSuffix).rjust(labelLength-gTimeWidthAdjust)

#####################################################
#
# shows counts display
#
#####################################################
def getCountDisplay(count, labelLength):
  global gCountSuffix
  global gCountWidthAdjust
  global gDiffRequested
  if (gDiffRequested):
    if (count > 0):
      return (("+"+str(count)).rjust(8)+gCountSuffix).rjust(labelLength-gCountWidthAdjust)
    else:
      return (str(count).rjust(8)+gCountSuffix).rjust(labelLength-gCountWidthAdjust)
  else:
    return (str(count).ljust(labelLength)+gCountSuffix).rjust(labelLength-gCountWidthAdjust)

#####################################################
#
# shows the current profile
#
#####################################################
def showProfile(logfile, outfile, option, count, fileFilter, functionFilter, profiles):
  global gBanner
  global gBannerLength

  global gCountLabel
  global gCountLabelLength

  global gTotTimeLabel
  global gMaxTimeLabel
  global gMinTimeLabel
  global gAvgTimeLabel
  global gMedTimeLabel
  global gStdDevLabel
  global gLabelSuffix

  global gTimeDeltaLength
  global gTimeDeltaCount

  global gUnderline

  global gSpaceLength

  global gNormalDisplayPadLength
  global gMismatchDisplayPadLength

  global gNoFilter
  global gClearStatusUpdate

  global gDiffRequested
  
  global gAreaLabel1
  global gAreaLabel2
  
  global gMinAreaWidth1
  global gMinAreaWidth2

  global gMaxAreaWidth1
  global gMaxAreaWidth2

  totalDisplayedTime = datetime.timedelta(0)
  gCountLabelLength = len(gCountLabel)+len(gLabelSuffix)+1

  if (outfile == "none"):
    file = sys.stdout
  else:
    file = open(outfile, "w+")
    gClearStatusUpdate = "\n"

  # see if we need to sort our profile
  if (option == "max"):
    profiles["profile"].sort(key=operator.itemgetter('max'), reverse=True)
  elif (option == "min"):
    profiles["profile"].sort(key=operator.itemgetter('min'), reverse=True)
  elif (option == "avg"):
    profiles["profile"].sort(key=operator.itemgetter('avg'), reverse=True)
  elif (option == "med"):
    profiles["profile"].sort(key=operator.itemgetter('med'), reverse=True)
  elif (option == "std"):
    profiles["profile"].sort(key=operator.itemgetter('stdDev'), reverse=True)
  elif (option == "tot"):
    profiles["profile"].sort(key=operator.itemgetter('tot'), reverse=True)
  elif (option == "count"):
    profiles["profile"].sort(key=operator.itemgetter('count'), reverse=True)

  maxAreaWidth1 = gMinArea1Width
  maxAreaWidth2 = gMinArea2Width
  maxTotTimeWidth = gTimeDeltaLength
  maxMaxTimeWidth = gTimeDeltaLength
  maxMinTimeWidth = gTimeDeltaLength
  maxMedTimeWidth = gTimeDeltaLength
  maxAvgTimeWidth = gTimeDeltaLength
  maxStdDevTimeWidth = gTimeDeltaLength

  if ((count != gDisplayAll) or (fileFilter != gNoFilter) or (functionFilter != gNoFilter)):
    numDisplayed = 0
    for profile in profiles["profile"]:
      if ((((fileFilter == gNoFilter) and (functionFilter == gNoFilter)) or
           ((fileFilter != gNoFilter) and (functionFilter == gNoFilter) and ((fileFilter in profile["file1"]) or (fileFilter in profile["file2"]))) or
           ((functionFilter != gNoFilter) and (fileFilter == gNoFilter) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))) or
           (((fileFilter in profile["file1"]) or (fileFilter in profile["file2"])) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))))):
        numDisplayed += 1
        maxAreaWidth1 = max(maxAreaWidth1, profile["areaWidth1"])
        maxAreaWidth2 = max(maxAreaWidth2, profile["areaWidth2"])
        maxTotTimeWidth = max(maxTotTimeWidth, len(str(profile["tot"])))
        maxMaxTimeWidth = max(maxMaxTimeWidth, len(str(profile["max"])))
        maxMinTimeWidth = max(maxMinTimeWidth, len(str(profile["min"])))
        maxMedTimeWidth = max(maxMedTimeWidth, len(str(profile["med"])))
        maxAvgTimeWidth = max(maxAvgTimeWidth, len(str(profile["avg"])))
        maxStdDevTimeWidth = max(maxStdDevTimeWidth, len(str(profile["stdDev"])))
      if ((count != gDisplayAll) and (numDisplayed >= int(count))):
        break
  else:
    # we're displaying everything
    maxAreaWidth1 = gMaxAreaWidth1
    maxAreaWidth2 = gMaxAreaWidth2

  # display our header
  maxFieldWidth = maxAreaWidth1 + \
                  maxAreaWidth2 + \
                  gCountLabelLength + \
                  maxTotTimeWidth + \
                  maxMaxTimeWidth + \
                  maxMinTimeWidth + \
                  maxMedTimeWidth + \
                  maxAvgTimeWidth + \
                  maxStdDevTimeWidth + \
                  gNormalDisplayPadLength
  file.write("%s%s\n" % (gClearStatusUpdate, gBanner.center(maxFieldWidth)))
  file.write("%s\n" % (gUnderline*max(len(logfile), gBannerLength)).center(maxFieldWidth))
  file.write("%s\n" % logfile.center(maxFieldWidth))
  file.write("\n")
  file.write("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n" % (gAreaLabel1.ljust(maxAreaWidth1),
                                                       ' '.ljust(gSpaceLength),
                                                       gAreaLabel2.ljust(maxAreaWidth2),
                                                       ' '.ljust(gSpaceLength),
                                                       (gCountLabel+gLabelSuffix).ljust(gCountLabelLength),
                                                       ' '.ljust(gSpaceLength),
                                                       (gTotTimeLabel+gLabelSuffix).ljust(maxTotTimeWidth),
                                                       ' '.ljust(gSpaceLength),
                                                       (gMaxTimeLabel+gLabelSuffix).ljust(maxMaxTimeWidth),
                                                       ' '.ljust(gSpaceLength),
                                                       (gMinTimeLabel+gLabelSuffix).ljust(maxMinTimeWidth),
                                                       ' '.ljust(gSpaceLength),
                                                       (gMedTimeLabel+gLabelSuffix).ljust(maxMedTimeWidth),
                                                       ' '.ljust(gSpaceLength),
                                                       (gAvgTimeLabel+gLabelSuffix).ljust(maxAvgTimeWidth),
                                                       ' '.ljust(gSpaceLength),
                                                       (gStdDevLabel+gLabelSuffix).ljust(maxStdDevTimeWidth)))
  file.write("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n" % (gUnderline.ljust(maxAreaWidth1, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxAreaWidth2, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gCountLabelLength, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxTotTimeWidth, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxMaxTimeWidth, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxMinTimeWidth, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxMedTimeWidth, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxAvgTimeWidth, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxStdDevTimeWidth, gUnderline)))
  # display our profile
  numDisplayed = 0
  for profile in profiles["profile"]:
    if ((((fileFilter == gNoFilter) and (functionFilter == gNoFilter)) or
         ((fileFilter != gNoFilter) and (functionFilter == gNoFilter) and ((fileFilter in profile["file1"]) or (fileFilter in profile["file2"]))) or
         ((functionFilter != gNoFilter) and (fileFilter == gNoFilter) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))) or
         (((fileFilter in profile["file1"]) or (fileFilter in profile["file2"])) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))))):
      numDisplayed += 1
      if (not gDiffRequested):
        totalDisplayedTime += profile["tot"]
      area1 = profile["file1"] + profile["function1"] + str(profile["line1"])
      area2 = profile["file2"] + profile["function2"] + str(profile["line2"])
      file.write("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n" % (area1.ljust(maxAreaWidth1),
                                                           ' '.ljust(gSpaceLength),
                                                           area2.ljust(maxAreaWidth2),
                                                           ' '.ljust(gSpaceLength),
                                                           getCountDisplay(profile["count"], gCountLabelLength).ljust(gCountLabelLength),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["tot"], maxTotTimeWidth).ljust(maxTotTimeWidth),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["max"], maxMaxTimeWidth).ljust(maxMaxTimeWidth),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["min"], maxMinTimeWidth).ljust(maxMinTimeWidth),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["med"], maxMedTimeWidth).ljust(maxMedTimeWidth),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["avg"], maxAvgTimeWidth).ljust(maxAvgTimeWidth),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["stdDev"], maxStdDevTimeWidth).ljust(maxStdDevTimeWidth)))
    if ((count != gDisplayAll) and (numDisplayed >= int(count))):
      break
  if (outfile != "none"):
    print("")
    print("")
    print("Results written to output file: %s" % outfile)
    print("")
  file.write("\n")
  if (not gDiffRequested):
    file.write("\n")
    file.write("RESULTS SUMMARY:\n")
    file.write("%s\n" % gUnderline.ljust(max(len(logfile), len(str(profiles["profiledTime"])), len(str(totalDisplayedTime)))+20, gUnderline))
    file.write("Logfile         : %s\n" % logfile)
    file.write("Profiled Time   : %s\n" % str(profiles["profiledTime"]))
    file.write("Displayed Time  : %s\n" % str(totalDisplayedTime))
    file.write("Total Areas     : %s\n" % len(profiles["profile"]))
    file.write("Displayed Areas : %d\n" % numDisplayed)
    file.write("\n")

#####################################################
#
# returns the diff between two time deltas
#
#####################################################
def getTimedeltaDiff(timedelta1, timedelta2):
  global gDiffType
  if (timedelta1 > timedelta2):
    if (gDiffType == "percent"):
      return -round((float(timeDeltaToUsec(timedelta1)-timeDeltaToUsec(timedelta2))/float(timeDeltaToUsec(timedelta1))*100.0), 1)
    else:  # diffType == "time"
      return -int(timeDeltaToUsec(timedelta1)-timeDeltaToUsec(timedelta2))
  elif (timedelta2 > timedelta1):
    if (gDiffType == "percent"):
      if (timeDeltaToUsec(timedelta1) > 0):
        return round((float(timeDeltaToUsec(timedelta2)-timeDeltaToUsec(timedelta1))/float(timeDeltaToUsec(timedelta1))*100.0), 1)
      else:
        return "Infinity"
    else:  # diffType == "time"
      return int(timeDeltaToUsec(timedelta2)-timeDeltaToUsec(timedelta1))
  else:
    if (gDiffType == "percent"):
      return 0.0
    else:  # diffType == "time"
      return 0

#####################################################
#
# returns the diff between two count counts
#
#####################################################
def getCountsDiff(count1, count2):
  global gDiffType
  if (count1 > count2):
    if (gDiffType == "percent"):
      return -round(((float(count1-count2)/float(count1))*100.0), 1)
    else:  # diffType == "time"
      return -int(count1-count2)
  elif (count2 > count1):
    if (gDiffType == "percent"):
      if (count1 > 0):
        return round(((float(count2-count1)/float(count1))*100.0), 1)
      else:
        return "Infinity"
    else:  # diffType == "time"
      return int(count2-count1)
  else:
    if (gDiffType == "percent"):
      return 0.0
    else:  # diffType == "time"
      return 0

#####################################################
#
# calculate the diffs between two profiles
#
#####################################################
def diffProfiles(profiles1, profiles2):
  global gDiffType
  global gProfilesDiff
  global gLabelSuffix
  global gTimeSuffix
  global gTimeWidthAdjust
  global gCountSuffix
  global gCountWidthAdjust
  if (gDiffType == "percent"):
    gLabelSuffix = " %diff"
    gTimeSuffix = "%"
    gCountSuffix = "%"
    gTimeWidthAdjust = 5
    gCountWidthAdjust = 5
  else:  # diffType == "time"
    gLabelSuffix = " diff"
    gTimeSuffix = " Usec"
    gTimeWidthAdjust = 3
    gCountWidthAdjust = 5
  gProfilesDiff = {"profile":[]}
  for profile1 in profiles1:
    profile2 = findProfile(profiles2, 
                           profile1["file1"], profile1["function1"], profile1["line1"], 
                           profile1["file2"], profile1["function2"], profile1["line2"])
    if (profile2 != None):
      gProfilesDiff["profile"].append({"file1":profile1["file1"],
                                       "function1":profile1["function1"],
                                       "line1":profile1["line1"],
                                       "areaWidth1":profile1["areaWidth1"],
                                       "file2":profile1["file2"],
                                       "function2":profile1["function2"],
                                       "line2":profile1["line2"],
                                       "areaWidth2":profile1["areaWidth2"],
                                       "count":getCountsDiff(profile1["count"], profile2["count"]),
                                       "tot":getTimedeltaDiff(profile1["tot"], profile2["tot"]),
                                       "min":getTimedeltaDiff(profile1["min"], profile2["min"]),
                                       "max":getTimedeltaDiff(profile1["max"], profile2["max"]),
                                       "avg":getTimedeltaDiff(profile1["avg"], profile2["avg"]),
                                       "med":getTimedeltaDiff(profile1["med"], profile2["med"]),
                                       "stdDev":getTimedeltaDiff(profile1["stdDev"], profile2["stdDev"])})

#####################################################
#
# find the timestamp from the input line
#
#####################################################
def findTimestamp(line):
  global gTimestampEndings
  global gTimestampPositions
  global gTimestampRegexp0
  global gTimestampRegexp1
  global gTimestampRegexp2
  global gTimestampRegexp3
  global gTimestampRegexp4
  timestamp = line.split()
  for position in gTimestampPositions:
    if ((len(timestamp) > position) and (":" in timestamp[position])):
      if (timestamp[position][-1] in gTimestampEndings):
        timestamp = timestamp[position][:-1].strip()
      else:
        timestamp = timestamp[position].strip()
      if ('T' in timestamp):
        timestamp = timestamp.split("T")[-1]
      if (re.match(gTimestampRegexp0, timestamp) or
          re.match(gTimestampRegexp1, timestamp) or
          re.match(gTimestampRegexp2, timestamp) or
          re.match(gTimestampRegexp3, timestamp)):
        return (timestamp)
  return ("")

#######################################################
#
# show all areas whose time delta is >= specified time
#
#######################################################
def createDelta(profile, maxTimeDelta):
  global gKeepAliveType
  global gProfilesDelta

  gProfilesDelta = {"logfile":profile["logfile"], 
                    "appFilter":profile["appFilter"],
                    "maxTimeDelta":maxTimeDelta, 
                    "maxTimeDeltaDiff":0.0, 
                    "minTimeDeltaDiff":sys.float_info.max, 
                    "delta":[]}
  sys.stdout.write("\n")
  sys.stdout.write("Creating time delta profile from logfile: %s, please wait...processing line: " % profile["logfile"])
  numLines = 0
  currLine = ""
  currTimestampStr = ""
  currLineNum = 1
  for line in profile["contents"]:
    printKeepAlive(numLines, len(profile["contents"]), gKeepAliveType)
    numLines += 1
    if (findApp(line, gProfilesDelta["appFilter"]) == True):
      timestamp = findTimestamp(line)
      if (timestamp != ""):
        prevLineNum = currLineNum
        currLineNum = numLines
        prevLine = currLine
        currLine = line
        prevTimestampStr = currTimestampStr
        currTimestampStr = timestamp
        if (prevTimestampStr != ""):
          currTimestamp = datetime.datetime.strptime(currTimestampStr, gTimestampFormat)
          prevTimestamp = datetime.datetime.strptime(prevTimestampStr, gTimestampFormat)
          timestampDiff = timeDeltaToSec(currTimestamp - prevTimestamp)
          if (timestampDiff >= maxTimeDelta):
            if (timestampDiff > gProfilesDelta["maxTimeDeltaDiff"]):
              gProfilesDelta["maxTimeDeltaDiff"] = timestampDiff
            if (timestampDiff < gProfilesDelta["minTimeDeltaDiff"]):
              gProfilesDelta["minTimeDeltaDiff"] = timestampDiff
            gProfilesDelta["delta"].append({"lineNum1":prevLineNum,
                                            "line1":prevLine.strip(),
                                            "lineNum2":currLineNum,
                                            "line2":currLine.strip(),
                                            "delta":timestampDiff})
  sys.stdout.write("\n")

#######################################################
#
# show all areas whose time delta is >= specified time
#
#######################################################
def showDelta(outfile, option, count):
  global gNoFilter
  global gProfilesDelta

  # see if we need to sort our profile
  if (option == "max"):
    gProfilesDelta["delta"].sort(key=operator.itemgetter('delta'), reverse=True)
  elif (option == "min"):
    gProfilesDelta["delta"].sort(key=operator.itemgetter('delta'), reverse=False)
  maxTimeDeltaDiff = 0.0
  minTimeDeltaDiff = sys.float_info.max
  if (outfile == "none"):
    outfile = sys.stdout
  else:
    outfile = open(outfile, "w+")
  numDisplayed = 0
  outfile.write("\n")
  outfile.write("LOGFILE TIME DELTA PROFILE:\n")
  outfile.write("=====================================\n")
  outfile.write("Logfile          : %s\n" % gProfilesDelta["logfile"])
  outfile.write("Time Delta (Sec) : %f\n" % gProfilesDelta["maxTimeDelta"])
  for profile in gProfilesDelta["delta"]:
    if ((count == gDisplayAll) or (numDisplayed < int(count))):
      outfile.write("\n")
      outfile.write("Time Delta (sec): %f\n" % profile["delta"])
      outfile.write("===============================\n")
      outfile.write("%s%d:%s %s\n" % (gHighlight, profile["lineNum1"], gNormal, profile["line1"]))
      outfile.write("%s%d:%s %s\n" % (gHighlight, profile["lineNum2"], gNormal, profile["line2"]))
      numDisplayed += 1
      if (profile["delta"] > maxTimeDeltaDiff):
        maxTimeDeltaDiff = profile["delta"]
      if (profile["delta"] < minTimeDeltaDiff):
        minTimeDeltaDiff = profile["delta"]
  outfile.write("\n")
  outfile.write("\n")
  outfile.write("RESULTS SUMMARY:\n")
  outfile.write("==============================================\n")
  outfile.write("Logfile                   : %s\n" % gProfilesDelta["logfile"])
  outfile.write("Time Delta (sec)          : %f\n" % gProfilesDelta["maxTimeDelta"])
  if (gProfilesDelta["maxTimeDeltaDiff"] > 0.0):
    outfile.write("Total Max Delta (sec)     : %f\n" % gProfilesDelta["maxTimeDeltaDiff"])
    outfile.write("Displayed Max Delta (sec) : %f\n" % maxTimeDeltaDiff)
    outfile.write("Total Min Delta (sec)     : %f\n" % gProfilesDelta["minTimeDeltaDiff"])
    outfile.write("Displayed Min Delta (sec) : %f\n" % minTimeDeltaDiff)
  outfile.write("Total Areas               : %d\n" % len(gProfilesDelta["delta"]))
  outfile.write("Displayed Areas           : %d\n" % numDisplayed)
  outfile.write("\n")

#####################################################
#
# find the first valid file in the arg list
#
#####################################################
def findFirstFileArg(args):
  index = 1
  for arg in sys.argv[index:]:
    if (os.path.isfile(arg)):
      break
    index += 1
  return index

##########################################################
#
# show all the profiled files information
#
##########################################################
def showProfiles():
  global gProfiles
  print("")
  print("****************************")
  print("*       PROFILE LIST       *")
  print("****************************")
  print("")
  print("ID   TOT PROFILED TIME  APP FILTER     LOGFILE")
  print("===  =================  =============  ==================")
  id = 1
  for profile in gProfiles:
    print("%-3d  %17s  %-13s  %s" % (id, str(profile["profiledTime"]), profile["appFilter"], profile["logfile"]))
    id += 1
  print("")

##########################################################
#
# show the interactive command usage
#
##########################################################
def showCommands():
  global gProfiles
  print("")
  print("Usage: show {profiles | {[profiles=<idList>] [sort=<sortType>] [disp=<count>] [file=<name>] [func=<name>] [out=<outfile>] [delta=<time>] [diff=<type>]}}")
  print("")
  print("  where:")
  print("    profiles   : Show a list of all profiled logfiles or specify profile <idList>")
  print("    sort       : Sort results based on specified <sortType>")
  print("    disp       : Specify number of entries to display")
  print("    file       : Specify a file name display filter")
  print("    func       : Specify a function name display filter")
  print("    out        : Specify an output file to write the results")
  print("    diff       : Compute diff between two profiles")
  print("    delta      : Show all areas that are >= specified time")
  print("    <idList>   : List of profile IDs to process (default=1)")
  print("    <sortType> : Desired sort type")
  print("      tot      : Sort highest to lowest total time")
  print("      min      : Sort highest to lowest minimum time")
  print("      max      : Sort highest to lowest maximum time")
  print("      avg      : Sort highest to lowest average time")
  print("      med      : Sort highest to lowest median time")
  print("      std      : Sort highest to lowest standard deviation time")
  print("      count    : Sort highest to lowest occurance count")
  print("    <count>    : The number of entries to display")
  print("    <name>     : Name (or substring) of file/function display filter")
  print("    <type>     : The desired diff type, valid values are 'percent' and 'time'")
  print("    <time>     : The time delta in seconds (float)")
  print("    <outfile>  : Name of the output file to write the results")
  print("")
  print("  NOTES:")
  print("")
  print("    If doing a non-diff profile, as many profile IDs can be given as desired,")
  print("    for a 'diff' based profile, exactly two profile IDs must be given, for a")
  print("    time 'delta' based analysis, only one profile ID should be provided.")
  print("")
  
##########################################################
#
# get interactive user input and perform desired action
#
##########################################################
def getInput():
  global gProfiles
  global gDiffType
  global gDisplayAll
  global gNoFilter
  global gValidDiffs
  global gValidSort
  global gDiffRequested

  command = ""
  while (not PshellReadline.isSubString(command, "quit")):
    (command, idleSession) = PshellReadline.getInput("logProfiler> ")
    if (not PshellReadline.isSubString(command, "quit")):
      outfile = "none"
      filter = "none"
      sort = gNoSort
      count = gDisplayAll
      fileFilter = gNoFilter
      functionFilter = gNoFilter
      gDiffRequested = False
      deltaRequested = False
      idList = []
      args = command.split()
      if ((len(args) < 2) or not PshellReadline.isSubString(args[0], "show") or (args[0] == '?') or (args[0] == '-h') or (args[0] == 'help')):
        showCommands()
        continue
      elif (PshellReadline.isSubString(args[1], "profiles")):
        showProfiles()
        continue
      else:
        validInput = True
        for arg in args[1:]:
          option = arg.split("=")
          if (len(option) == 2):
            option[0] = option[0].strip()
            option[1] = option[1].strip()
            if (PshellReadline.isSubString(option[0], "profiles")):
              profileIds = option[1].split(",")
              for id in profileIds:
                intId = int(id)-1
                if (intId in idList):
                  print("ERROR: ID: %d already in idList" % (intId+1))
                  validInput = False
                  break
                elif (intId >= len(gProfiles)):
                  print("ERROR: ID: %d out of profile ID range, 1-%d" % (intId+1, len(gProfiles)))
                  validInput = False
                  break
                else:
                  idList.append(intId)
            elif (PshellReadline.isSubString(option[0], "sort")):
              if (option[1] in gValidSort):
                sort = option[1]
              else:
                print("ERROR: Invalid sort specifier: '%s'" % option[1])
                validInput = False
                break
            elif (PshellReadline.isSubString(option[0], "disp", 3)):
              count = option[1]
            elif (PshellReadline.isSubString(option[0], "file", 2)):
              fileFilter = option[1]
            elif (PshellReadline.isSubString(option[0], "func", 2)):
              functionFilter = option[1]
            elif (PshellReadline.isSubString(option[0], "out")):
              outfile = option[1]
            elif (PshellReadline.isSubString(option[0], "delta", 2)):
              maxTimeDelta = option[1]
              deltaRequested = True
            elif (PshellReadline.isSubString(option[0], "diff", 3)):
              gDiffRequested = True
              if (option[1] in gValidDiffs):
                gDiffType = option[1]
              else:
                print("ERROR: Invalid diff type: '%s'" % option[1])
                validInput = False
                break
            else:
              print("ERROR: Invalid option: '%s'" % option[0])
              validInput = False
              break
          else:
            print("ERROR: Invalid arg: '%s'" % arg)
            validInput = False
            break
      if (validInput):
        # process command line selections
        # if not idList populated, default to 0
        if (len(idList) == 0):
          idList = [0]        
        if (deltaRequested):
          if (len(idList) == 1):
            createDelta(gProfiles[idList[0]], float(maxTimeDelta))
            showDelta(outfile, sort, count)
          else:
            print("ERROR: Can only supply one profile ID for time delta")
        elif (gDiffRequested):
          if (len(idList) == 2):
            diffProfiles(gProfiles[idList[0]]["profile"], gProfiles[idList[1]]["profile"])
            showProfile("Diff: %s->%s" % (gProfiles[idList[0]]["logfile"], gProfiles[idList[1]]["logfile"]), outfile, sort, count, fileFilter, functionFilter, gProfilesDiff)
          else:
            print("ERROR: Diff must supply exactly two profile IDs")
        elif (len(gProfiles) > 0):
          for id in idList:
            showProfile(gProfiles[id]["logfile"], outfile, sort, count, fileFilter, functionFilter, gProfiles[id])

##############################
#
# start of main program
#
##############################
if (__name__ == '__main__'):

  # validate usage and create profile
  if ((len(sys.argv) < 2) or (sys.argv[1] == "-h")):
    showUsage()
  else:
    # read in all our logfiles & create profiles
    gProfiles = []
    for arg in sys.argv[1:]:
      logfile = arg
      createProfile(logfile)
    print("\n\nProfiles created, entering interactive mode...\n")
    print("Type '?', '-h', or 'help' for usage, 'quit' to exit")
    print ("Up-arrow recall and command line editing supported")
    print ("Command and option abbreviation supported\n")
    getInput()
